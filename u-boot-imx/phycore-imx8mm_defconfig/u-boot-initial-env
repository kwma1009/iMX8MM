bootcmd=mmc dev ${mmcdev}; if mmc rescan; then env exists dofitboot || setenv dofitboot 0;env exists doraucboot || setenv doraucboot 0 && saveenv;if test ${doraucboot} = 1; then run raucboot; elif run loadimage; then run mmcboot; else run netboot; fi; fi; 
bootdelay=2
baudrate=115200
loadaddr=0x40480000
image=Image
console=ttymxc2
fdt_addr=0x48000000
fdto_addr=0x49000000
bootcmd_mfg=fastboot 0
bootenv_addr=0x49100000
fdt_file=oftree
ipaddr=192.168.3.11
serverip=192.168.3.10
netmask=255.225.255.0
ip_dyn=no
bootenv=bootenv.txt
mmc_load_bootenv=fatload mmc ${mmcdev}:${mmcpart} ${bootenv_addr} ${bootenv}
mtdids=nor0=30bb0000.spi
spiprobe=true
emmc_dev=2
sd_dev=1
mmcdev=2
mmcpart=1
mmcroot=2
mmcautodetect=yes
mmcargs=setenv bootargs console=${console},${baudrate} root=/dev/mmcblk${mmcdev}p${mmcroot} fsck.repair=yes rootwait rw 
loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}
loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}
mmc_load_overlay=fatload mmc ${mmcdev}:${mmcpart} ${fdto_addr} ${overlay}
mmc_apply_overlays=fdt address ${fdt_addr}; if test ${no_extensions} = 0; then setenv extension_overlay_addr ${fdto_addr}; setenv extension_overlay_cmd 'fatload mmc ${mmcdev}:${mmcpart} ${fdto_addr} ${extension_overlay_name}'; extension scan; extension apply all; fi; if test ${no_overlays} = 0; then for overlay in $overlays; do; if run mmc_load_overlay; then fdt resize ${filesize}; fdt apply ${fdto_addr}; fi; done;fi;
 mmcboot=echo Booting from mmc ...; run spiprobe; if run mmc_load_bootenv; then env import -t ${bootenv_addr} ${filesize}; fi; run mmcargs; run fit_test_and_run_boot; if run loadfdt; then run mmc_apply_overlays; booti ${loadaddr} - ${fdt_addr}; else echo WARN: Cannot load the DT; fi;
 nfsroot=/nfs
netargs=setenv bootargs console=${console},${baudrate} root=/dev/nfs ip=${nfsip} nfsroot=${serverip}:${nfsroot},v3,tcp
net_load_bootenv=${get_cmd} ${bootenv_addr} ${bootenv}
net_load_overlay=${get_cmd} ${fdto_addr} ${overlay}
net_apply_overlays=fdt address ${fdt_addr}; if test ${no_extensions} = 0; then setenv extension_overlay_addr ${fdto_addr}; setenv extension_overlay_cmd '${get_cmd} ${fdto_addr} ${extension_overlay_name}'; extension scan; extension apply all; fi; if test ${no_overlays} = 0; then for overlay in $overlays; do; if run net_load_overlay; then fdt resize ${filesize}; fdt apply ${fdto_addr}; fi; done;fi;
 netboot=echo Booting from net ...; run spiprobe; if test ${ip_dyn} = yes; then setenv nfsip dhcp; setenv get_cmd dhcp; else setenv nfsip ${ipaddr}:${serverip}::${netmask}::eth0:on; setenv get_cmd tftp; fi; if run net_load_bootenv; then env import -t ${bootenv_addr} ${filesize}; fi; run netargs; ${get_cmd} ${loadaddr} ${image}; if ${get_cmd} ${fdt_addr} ${fdt_file}; then run net_apply_overlays; booti ${loadaddr} - ${fdt_addr}; else echo WARN: Cannot load the DT; fi;
raucdev=2
raucslot=system0
raucbootpart=1
raucrootpart=5
raucbootpart0=1
raucrootpart0=5
raucbootpart1=2
raucrootpart1=6
raucargs=setenv bootargs console=${console},${baudrate} root=/dev/mmcblk${raucdev}p${raucrootpart} rauc.slot=${raucslot} rootwait rw
loadraucimage=fatload mmc ${raucdev}:${raucbootpart} ${loadaddr} ${image}
loadraucfdt=fatload mmc ${raucdev}:${raucbootpart} ${fdt_addr} ${fdt_file}
loadrauc_bootenv=fatload mmc ${raucdev}:${raucbootpart} ${bootenv_addr} ${bootenv}
rauc_apply_overlays=fdt address ${fdt_addr}; if test ${no_extensions} = 0; then setenv extension_overlay_addr ${fdto_addr}; setenv extension_overlay_cmd 'fatload mmc ${raucdev}:${raucbootpart} ${fdto_addr} ${extension_overlay_name}'; extension scan; extension apply all; fi; if test ${no_overlays} = 0; then for overlay in $overlays; do if run mmc_load_overlay; then fdt resize ${filesize}; fdt apply ${fdto_addr}; fi; done;fi;
raucemmcboot=echo Booting A/B system from eMMC...; if run loadrauc_bootenv; then env import -t ${bootenv_addr} ${filesize}; fi; if run loadraucimage; then run raucargs; run fit_test_and_run_boot; if run loadraucfdt; then run rauc_apply_overlays; booti ${loadaddr} - ${fdt_addr}; else echo WARN: Cannot load device tree; fi; else echo WARN: Cannot load kernel image; fi;
raucboot=test -n "${BOOT_ORDER}" || setenv BOOT_ORDER "system0 system1"; test -n "${BOOT_system0_LEFT}" || setenv BOOT_system0_LEFT 3; test -n "${BOOT_system1_LEFT}" || setenv BOOT_system1_LEFT 3; setenv raucstatus; for BOOT_SLOT in "${BOOT_ORDER}"; do if test "x${raucstatus}" != "x"; then echo Skipping remaing slots!; elif test "x${BOOT_SLOT}" = "xsystem0"; then if test ${BOOT_system0_LEFT} -gt 0; then echo "Found valid slot A, ${BOOT_system0_LEFT} attempts remaining"; setexpr BOOT_system0_LEFT ${BOOT_system0_LEFT} - 1; setenv raucbootpart ${raucbootpart0}; setenv raucrootpart ${raucrootpart0}; setenv raucslot system0; run raucargs; setenv raucstatus success; fi; elif test "x${BOOT_SLOT}" = "xsystem1"; then if test ${BOOT_system1_LEFT} -gt 0; then echo "Found valid slot B, ${BOOT_system1_LEFT} attempts remaining"; setexpr BOOT_system1_LEFT ${BOOT_system1_LEFT} - 1; setenv raucbootpart ${raucbootpart1}; setenv raucrootpart ${raucrootpart1}; setenv raucslot system1; run raucargs; setenv raucstatus success; fi; fi; done; if test -n "${raucstatus}"; then env delete raucstatus; saveenv; run raucemmcboot; else echo "WARN: No valid slot found"; setenv BOOT_system0_LEFT 3; setenv BOOT_system1_LEFT 3; env delete raucstatus; saveenv; reset; fi;
fit_create_overlay_conf_spec=fdt address ${loadaddr}; fdt get value default_fit_conf /configurations/ default; overlay_specs="${loadaddr}:#${default_fit_conf}"; for overlay in ${overlays}; do overlay_specs=${overlay_specs}#${overlay}; done; env set bootm_fit_conf_spec ${overlay_specs};
fit_test_and_run_boot=if test ${dofitboot} = 1; then if test ${no_overlays} = 0; then run fit_create_overlay_conf_spec; bootm ${bootm_fit_conf_spec};else bootm; fi; fi;


